/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package cryptoutils;

import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.security.*;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.util.Base64;
import java.util.Properties;


public class CryptoUtils {
    public static EncryptedMessage em=new EncryptedMessage();
    public static void main(String[] args) throws NoSuchPaddingException, NoSuchAlgorithmException, IOException, InvalidKeySpecException, InvalidAlgorithmParameterException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        //getSalt() function
        byte[] salt12 = getSalt();
        byte[] salt3 = getSalt();

        //getDigest() function
        String digest1 = getDigest("teknos", salt12);
        String digest2 = getDigest("teknos", salt12);
        String digest3 = getDigest("teknos", salt3);
        System.out.println("digest1:" + digest1);
        System.out.println("digest2:" + digest2);
        System.out.println("digest3:" + digest3);

        //Hash() function
        byte[] m1="carlota".getBytes();
        byte[] m2="carlota".getBytes();

        DigestResult dr1=Hash(m1);
        DigestResult dr2=Hash(m2);

        System.out.println("hash1: "+dr1.getHash().toString());
        System.out.println("hash2: "+dr2.getHash().toString());

        //encrypt() function
        Properties prop = new Properties();
        prop.load(new FileReader("cryptoUtils.properties"));
        String algorithm= (String) prop.get("encrypt.algorithm");
        int iterations=(Integer) prop.get("encrypt.iterations");

        byte[] plainText = "carlota".repeat(iterations).getBytes();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);
        keyGenerator.init(128);
        String password = keyGenerator.generateKey().toString();
        byte[] encryptedText = Encrypt(plainText, password);

        System.out.println("Encrypted Text: "+encryptedText.toString());

        //Decrypt() function
        byte[] decriptedText=Decrypt(encryptedText,password);
        System.out.println("Decrypted Text: "+decriptedText.toString());

    }

    /**
     * getDigest()
     * gets digest
     *
     * @param String Data --> message
     * @param byte[] salt
     * @throws NoSuchAlgorithmException

     */
    public static String getDigest(String data, byte[] salt) throws NoSuchAlgorithmException {
        byte[] dataBytes = data.getBytes();
        MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
        messageDigest.update(salt);
        byte[] digest = messageDigest.digest(dataBytes);
        Base64.Encoder base64Encoder = Base64.getEncoder();
        return  base64Encoder.encodeToString(digest);
    }

    /**
     * getSalt()
     * generates Salt bytes
     *
     */
    public static byte[] getSalt() {
        SecureRandom sercureRandom = new SecureRandom();
        var salt = new byte[16];
        sercureRandom.nextBytes(salt);
        return salt;
    }

    /**
     * Hash()
     * extracxts hashs, algorithm and salt from encrypted message
     *
     * @param byte[] message
     * @return DigesRestult

     */
    public static DigestResult Hash(byte[] message){
        DigestResult digRes = new DigestResult();
        Properties prop = new Properties();
        try {
            prop.load(new FileReader("cryptoUtils.properties"));

            String salt = (String) prop.get("hash.salt");
            String algorithm=(String)prop.get("hash.algorithm");
            digRes.setAlgorithm(algorithm);

            byte[] saltBytes=getSalt();
            digRes.setSalt(saltBytes);
            MessageDigest messageDigest = MessageDigest.getInstance(algorithm);

            if (salt.equals("true")){
                messageDigest.update(saltBytes);
            }
            var hash = messageDigest.digest(message);
            digRes.setHash(hash);

        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
        return digRes;
    }

    /**
     * encrypt()
     * encrypts given message
     *
     * @param byte[] plain Text
     * @param String password
     * @return byte[] encryptedTest
     * @throws NoSuchPaddingException,
     *             NoSuchAlgorithmException, InvalidKeySpecException, InvalidAlgorithmParameterException,
     *             InvalidKeyException, IllegalBlockSizeException, BadPaddingException

     */
    public static byte[] Encrypt (byte[] plainText, String password) throws NoSuchPaddingException,
            NoSuchAlgorithmException, InvalidKeySpecException, InvalidAlgorithmParameterException,
            InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        //convert password to key
        Key convertedPassword= getPrivateKeyFromPassword(password);

        //get IV parameter
        SecureRandom secureRandom = new SecureRandom();
        byte[] salt = new byte[16];
        secureRandom.nextBytes(salt);
        IvParameterSpec iv = new IvParameterSpec(salt);

        //Encrypt Text
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, convertedPassword, iv);
        byte[] encryptedText = cipher.doFinal(plainText);
        em= new EncryptedMessage(encryptedText, salt);

        return encryptedText;
    }

    /**
     * Decrypt()
     * Decrypts given encrypted message
     *
     * @param byte[] encrypted Text
     * @param String password
     * @return byte[] encryptedTest
     * @throws IllegalBlockSizeException,BadPaddingException, NoSuchAlgorithmException, InvalidKeySpecException,
     *          NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException

     */
    public static byte[] Decrypt (byte[] encryptedText, String password) throws IllegalBlockSizeException,
            BadPaddingException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException,
            InvalidAlgorithmParameterException, InvalidKeyException {
        //convert password to key
        Key convertedPassword= getPrivateKeyFromPassword(password);

        //get salt
        IvParameterSpec salt = new IvParameterSpec(em.getSalt());

        //Decrypt de encrypted Text
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.DECRYPT_MODE, convertedPassword, salt);
        byte[] decryptedText = cipher.doFinal(encryptedText);

        return decryptedText;
    }

    /**
     * Sign()
     * Signs message with user A signature
     *
     * @param byte[] message
     * @return byte[] signature
     * @throws IOException,CertificateException, NoSuchAlgorithmException, UnrecoverableKeyException,
     *          KeyStoreException, InvalidKeyException, SignatureException

     */
    public static byte[] Sign(byte[]  message) throws IOException, CertificateException, NoSuchAlgorithmException,
            UnrecoverableKeyException, KeyStoreException, InvalidKeyException, SignatureException {
        //load properties
        Properties prop = new Properties();
        prop.load(new FileReader("cryptoUtils.properties"));
        String KeyStoreName=(String) prop.get("assymetric.keystorename");
        String p12Password= (String) prop.get("assymetric.p12Password");
        String passwordAlias=(String) prop.get("assymetric.keyAlias");
        String algorithm=(String) prop.get("assymetric.algorithm");

        //Get private key
        KeyStore keystore = KeyStore.getInstance("PKCS12");
        keystore.load(new FileInputStream(p12Password), KeyStoreName.toCharArray());
        Key privateKey = keystore.getKey(passwordAlias, KeyStoreName.toCharArray());

        Signature signer = Signature.getInstance(algorithm);
        signer.initSign((PrivateKey) privateKey);
        signer.update(message);
        byte[] signature = signer.sign();

        return(signature);
    }
    /**
     * Verify()
     * makes sure encrypted message has been sent from ehre it's supposed to
     *
     * @param byte[] message
     * @param byte[] signature
     * @param byte[] certificate
     * @return boolean it's sent from where it's supposed to
     * @throws IOException, CertificateException, NoSuchAlgorithmException, InvalidKeyException, SignatureException

     */

    public static boolean Verify(byte[]  message, byte[] signature, byte[] certificate) throws IOException,
            CertificateException, NoSuchAlgorithmException, InvalidKeyException, SignatureException {
        InputStream certificateStream= new ByteArrayInputStream(certificate);
        var certificateFactory = CertificateFactory.getInstance("X.509");
        var cert = certificateFactory.generateCertificate(certificateStream);
        try {
            ((X509Certificate) cert).checkValidity();
        } catch( Exception e) {
            System.out.println(e.getMessage());
        }
        var publicKey = cert.getPublicKey();

        Properties prop = new Properties();
        prop.load(new FileReader("cryptoUtils.properties"));
        String algorithm=(String) prop.get("assymetric.algorithm");

        Signature signer = Signature.getInstance(algorithm);
        signer.initVerify(publicKey);
        signer.update(message);

        boolean isValid = signer.verify(signature);

        return isValid;


    }

    /**
     * getPrivateKeyFromPassword()
     * generates a private key for each password
     *
     * @param Stirng password
     * @return Key private key from password
     * @throws NoSuchAlgorithmException, InvalidKeySpecException

     */
    private static Key getPrivateKeyFromPassword(String password) throws NoSuchAlgorithmException, InvalidKeySpecException {
        byte[] salt = new byte[100];
        SecureRandom random = new SecureRandom();
        random.nextBytes(salt);

        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, 1000, 256);
        SecretKey pbeKey = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256").generateSecret(pbeKeySpec);
        return new SecretKeySpec(pbeKey.getEncoded(), "AES");
    }
}
